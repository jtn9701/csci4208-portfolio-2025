name: Seed / Update Roadmap Issues

on:
  workflow_dispatch: {}   # manual trigger
  # Optional: auto-refresh daily (UTC)
  schedule:
     - cron: "59 4,5 * * *"

permissions:
  contents: read
  issues: write

concurrency:
  group: seeder-${{ github.ref }}
  cancel-in-progress: true

jobs:
  seed:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Load roadmap JSON (remote or local)
        id: load
        env:
          ROADMAP_SRC: ${{ vars.ROADMAP_SRC }}
          DEFAULT_SRC: https://raw.githubusercontent.com/scalemailted/FullStackApps/main/.github/roadmap.json
        run: |
          set -e
          TMP=/tmp/roadmap.json
          URL="${ROADMAP_SRC:-$DEFAULT_SRC}"
          echo "Fetching roadmap from: $URL"
          if curl --fail --silent --show-error --location "$URL" -o "$TMP"; then
            echo "Fetched remote roadmap.json"
          else
            echo "Remote fetch failed; falling back to local .github/roadmap.json"
            test -f .github/roadmap.json
            cp .github/roadmap.json "$TMP"
          fi
          echo 'JSON<<EOF' >> "$GITHUB_OUTPUT"; cat "$TMP" >> "$GITHUB_OUTPUT"; echo 'EOF' >> "$GITHUB_OUTPUT"

      - name: Upsert issues from roadmap.json
        uses: actions/github-script@v7
        env:
          ROADMAP_JSON: ${{ steps.load.outputs.JSON }}
          # Behavior toggles (can be set as repo "Variables")
          RESPECT_CLOSED: ${{ vars.RESPECT_CLOSED || 'true' }}               # keep closed issues closed
          DONT_REOPEN_IF_LABELED: ${{ vars.DONT_REOPEN_IF_LABELED || 'completed,approved' }}
          ENFORCE_CLOSE_IF_LABELED: ${{ vars.ENFORCE_CLOSE_IF_LABELED || '' }}  # e.g., 'approved'
          COURSE_DOCS: ${{ vars.COURSE_DOCS }}                               # optional docs URL
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;

            // Parse JSON safely
            let data;
            try {
              data = JSON.parse(process.env.ROADMAP_JSON || '[]');
              if (!Array.isArray(data)) throw new Error('roadmap.json must be a JSON array');
            } catch (e) {
              core.setFailed(`Failed to parse roadmap.json: ${e.message}`);
              return;
            }
            core.info(`Loaded ${data.length} items from roadmap.json`);

            const RESPECT_CLOSED = (process.env.RESPECT_CLOSED || 'true').toLowerCase() === 'true';
            const DO_NOT_REOPEN = new Set((process.env.DONT_REOPEN_IF_LABELED || 'completed,approved').split(',').map(s=>s.trim()).filter(Boolean));
            const ENFORCE_CLOSE = new Set((process.env.ENFORCE_CLOSE_IF_LABELED || '').split(',').map(s=>s.trim()).filter(Boolean));

            const docsLine = process.env.COURSE_DOCS
              ? `ðŸ“– See course repo docs: ${process.env.COURSE_DOCS}`
              : 'ðŸ“– See course repo for instructions and rubric.';

            async function ensureLabel(name, color='6a737d', description='') {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name, color, description }); }
            }

            // NOTE: uses milestone_number when updating (fix for 404)
            async function ensureMilestone(title, due_on) {
              const ms = await github.rest.issues.listMilestones({ owner, repo, state:'all', per_page: 100 });
              let hit = ms.data.find(m => m.title === title);
              if (!hit) {
                hit = (await github.rest.issues.createMilestone({
                  owner, repo, title, due_on: due_on || undefined
                })).data;
              } else if (due_on && hit.due_on !== due_on) {
                hit = (await github.rest.issues.updateMilestone({
                  owner, repo, milestone_number: hit.number, due_on
                })).data;
              }
              return hit.number;
            }

            async function findIssueByKeyOrTitle(key, title) {
              for (const state of ['open','closed']) {
                if (key) {
                  const r = await github.rest.issues.listForRepo({ owner, repo, state, labels: key, per_page: 100 });
                  if (r.data.length) return r.data[0];
                }
                const s = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:issue state:${state} in:title "${title}"`
                });
                if (s.data.total_count > 0) return s.data.items[0];
              }
              return null;
            }

            for (const it of data) {
              const key = it.key || (Array.isArray(it.labels)
                                     ? it.labels.find(x=>/^lab-|^project-|^capstone-|^part-/.test(x))
                                     : null);

              // Normalize incoming labels: drop legacy 'assignment', add 'task' + key
              const incoming = (it.labels || []).filter(l => l !== 'assignment');
              const baseLabels = Array.from(new Set([...incoming, 'task', key].filter(Boolean)));

              // Ensure labels exist
              for (const L of baseLabels) await ensureLabel(L);

              // Milestone (optional due_on from ISO due)
              const dueStr = it.due ? String(it.due) : '';
              const dueISO = /^\d{4}-\d{2}-\d{2}T/.test(dueStr) ? dueStr : null;
              const milestoneNumber = await ensureMilestone(it.milestone || it.title, dueISO);

              // Body with acceptance checklist
              const checklist = (it.acceptance || it.deliverables || [])
                .map(d => `- [ ] ${d}`).join('\n') || '- [ ] See course repo for instructions';

              const body = [
                '### ðŸŽ¯ Task', it.task || '',
                '', '### ðŸ“… Due (display)', it.due ? dueStr : 'â€”',
                '', '### âœ… Acceptance', checklist,
                '', docsLine,
                '', '---', `_Key:_ ${key || 'n/a'}`
              ].join('\n');

              // Find existing (open or closed) by key label, else by title
              const existing = await findIssueByKeyOrTitle(key, it.title);

              if (existing) {
                const existingNames = (existing.labels || []).map(l => l.name || l);
                const hasProtected = existingNames.some(n => DO_NOT_REOPEN.has(n));

                // Preserve protected labels (e.g., completed/approved)
                const preserved = existingNames.filter(n => DO_NOT_REOPEN.has(n));
                const mergedLabels = Array.from(new Set([...baseLabels, ...preserved]));

                const update = {
                  owner, repo,
                  issue_number: existing.number,
                  title: it.title,
                  body,
                  labels: mergedLabels,
                  milestone: milestoneNumber
                };

                // Reopen logic: respect closures unless toggled and not protected
                if (existing.state === 'closed' && !RESPECT_CLOSED && !hasProtected) {
                  update.state = 'open';
                }

                // Enforce close if labeled (optional)
                if (existing.state === 'open' && existingNames.some(n => ENFORCE_CLOSE.has(n))) {
                  update.state = 'closed';
                }

                await github.rest.issues.update(update);
                core.info(`Updated: #${existing.number} ${it.title} (${update.state || existing.state})`);
              } else {
                const created = await github.rest.issues.create({
                  owner, repo,
                  title: it.title,
                  body,
                  labels: baseLabels,
                  milestone: milestoneNumber
                });
                core.info(`Created: #${created.data.number} ${it.title}`);
              }
            }
